# 4장. 퍼사드의 다양성  
### 1. 구조 디자인 패턴 개요
- 객체와 클래스가 병합해 더 큰 구조를 만듦
- 개체의 관계를 더 쉽게 식별할 수 있음
- 클래스 패턴(The Class Pattern): 상속을 통해 추상화해 인터페이스를 제공  
객체 패턴(The Object Pattern): 한 개의 객체를 더 큰 객체로 확장시킴  
**구조 패턴**: 클래스 패턴과 객체 패턴을 합친 패턴


<br>

### 2. 구조 패턴의 예시
#### 1) 어댑터 패턴(The Adapter Pattern)
클라이언트의 요구에 따라 특정 인터페이스를 다른 인터페이스에 맞춤(서로 다른 클래스의 인터페이스를 변환)

#### 2) 브릿지 패턴(The Bridge Pattern)
객체의 인터페이스와 구현을 분리하여 독립적으로 동작할 수 있도록 함

#### 3) 데코레이터 패턴(The Decorator Pattern)
런타임에 객체의 책임을 덧붙임. 인터페이스를 통해 객체에 속성을 추가


<br>

### 3. 퍼사드 디자인 패턴 개요
- **퍼사드(façade)**: 건물의 정면, 특히 돋보이는 외관  
복잡한 내부 시스템 로직을 감추고 클라이언트가 쉽게 시스템에 접근할 수 있는 인터페이스를 제공


#### - 퍼사드 디자인 패턴의 목적
1. 서브시스템의 인터페이스를 통합시킨 단일 인터페이스를 제공하여 클라이언트가 쉽게 서브시스템에 접근할 수 있게 함
2. 단일 인터페이스 객체로 복잡한 서브시스템을 대체
3. **서브시스템을 캡슐화하지 않고** 서브시스템들을 결합
4. 클라이언트와 내부 구현을 분리


<br>

### 4. 퍼사드 패턴의 구성원의 역할
#### 1) **퍼사드**  
외부에서 보기에 깔끔하도록 복잡한 서브시스템을 감싸는 역할(메인 인터페이스)
   - 어떤 서브시스템이 요청에 알맞는지 알고 있는 인터페이스
   - **컴포지션**을 통해 클라이언트의 요청을 적합한 서브시스템 객체에 전달

#### 2) **시스템**  
전체 시스템을 하나의 복잡한 복합체로 만드는 여러 서브시스템의 집합
   - 서브시스템의 기능을 구현하는 클래스(각기 다른 역할을 하는 클래스의 집합)
   - 퍼사드 객체가 지시한 일을 담당하나 **퍼사드의 존재를 인지하지 않음**
   - 클라이언트가 퍼사드에 특정 서비스를 요청하면 퍼사드는 알맞은 서브시스템을 선택하고 반환함

#### 3) **클라이언트**  
**퍼사드**를 통해 서브시스템과 통신. 복잡한 시스템 구조에 대해 알 필요가 없음
   - 퍼사드를 인스턴스화하는 클래스
   - 퍼사드에 서브시스템을 통해 작업을 수행하도록 요청


<br>

### 5. 최소 지식 원칙
상호작용하는 객체를 밀접한 몇 개의 객체로 최소화함
   - 시스템 설계 시, 생성하는 모든 객체가 몇 개의 클래스와 연관되며 어떤 식으로 대화하는지 알아야 함
   - 원칙에 따라 지나치게 서로 얽혀있는 클래스를 만드는 것을 지양
   - 시스템의 한 부분을 수정하면 다른 부분이 의도치 않게 변경될 수 있으므로 클래스 간의 의존도가 높아지는 것을 지양
   - 각 유닛은 시스템 내의 다른 유닛에 대해 최소한의 지식만을 가져야함
   - 유닛은 주변의 친구와만 대화해야 함
   - 유닛은 자신이 다루는 객체의 **세부 사항**에 대해 알 필요가 없음

#### 1) 데메테르의 법칙  
최소 지식 원칙과 동일하며 느슨한 결합(Loose Coupling)을 원칙으로 함

#### 2) 단점
불필요한 인터페이스가 여러 개 존재하면 시스템의 복잡도가 높아지고 런타임 성능이 저하됨
