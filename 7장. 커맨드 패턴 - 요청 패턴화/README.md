# 7장. 커맨드 패턴 - 요청 패턴화
## 7.1 커맨드 디자인 패턴
> **커맨드 패턴** \
객체가 특정 기능을 바로 수행하거나 나중에 트리거할 때 피룡한 정보를 캡슐화하는 행동 패턴 \
(캡슐화되는 정보: 메소드명, 메소드를 소유하는 객체, 메소드 인자)


<br>

## 7.2 커맨드 패턴 구성 요소
1. **Command** \
Command 객체는 Receiver 객체에 대해 알고 있으며 Receiver 객체의 함수를 호출
2. **Receiver** \
Receiver 함수의 인자는 Command 객체에 저장돼 있음
3. **Invoker** \
명령을 수행
4. **Client** \
Command 객체를 생성하고 Receiver를 지정

### 7.2.1 커맨드 패턴의 목적
- 요청을 객체 속에 **캡슐화**
- 클라이언트의 다양한 요청을 매개변수화
- 요청을 큐에 저장
- 객체지향 콜백을 지원

### 7.2.2 커맨드 패턴이 적합한 상황
- 수행할 명령에 따라 객체를 변수화할 때
- **요청을 큐에 저장하고 각기 다른 시점에 수행해야 하는 경우**
- 작은 단위의 연산을 기반으로 하는 상위 연산을 만들 때


<br>

## 7.3 클라우드 기반 애플리케이션에서 발생할 수 있는 상황
### 7.3.1 리두(redo) 또는 롤백(rollback)의 두 가지 구현 방법
1. 파일시스템이나 메모리에 스냅샷을 생성하고 롤백이 필요할 때 해당 스냅샷 상태로 되돌림
2. 커맨드 패턴을 사용할 경우 커맨드를 순서대로 저장하고 리두가 필요할 때 저장된 명령을 순차적으로 실행

### 7.3.2 비동기 작업 수행
- 분산 환경에서 코어 서비스에 요청이 몰리지 않도록 작업을 비동기로 수행하는 경우가 많음
- 커맨드 패턴의 Invoker 객체는 모든 요청을 큐에 저장하고 순차적으로 Receiver 객체에 보내어 메인 스레드로부터 독립적으로 수행


<br>

## 7.4 커맨드 패턴의 장단점
### 7.4.1 장점
- 작업을 요청하는 클래스와 실제로 작업을 수행하는 클래스를 분리
- 큐에 커맨드를 순서대로 저장
- 기존 코드를 수정하지 않고 새로운 커맨드를 쉽게 추가할 수 있음
- 커맨드 패턴으로 롤백 시스템을 구현할 수 있음

### 7.4.2 단점
- 클래스와 객체가 많아짐
- 모든 작업이 독립적인 ConcreteCommand 클래스이므로 구현 및 유지보수해야 하는 클래스가 많음 (△)
- 